###界面

        设计的真谛，就是在一些互相冲突的需求和约束条件之间寻找平衡点。
        在进行设计的时候，必须考虑的问题包括：
        ● 界面：应该提供哪些服务与访问？界面在效能上实际成为服务的提供者和使用者之间的一个约定。在这里要做的是提供一种统一而方便的服
          务，使用方便，有足够丰富的功能，而又不过多过滥以至无法控制。
        ● 信息隐藏：哪些信息应该是可见的，哪些应该是私有的？一个界面必须提供对有关部件的方便访问方式，而同时又隐蔽其实现的细节。这样
          部件的修改才不会影响到使用者
        ● 资源管理：谁负责管理内存或者其他有限的资源？这里的主要问题是存储的分配和释放，以及管理共享信息的拷贝等。
        ● 错误处理：谁检查错误？谁报告？如何报告？如果检查中发现了错误，那么应该设法做哪些恢复性操作？
        在这一章里，我们将针对一个日常任务构造出一个函数库和一些数据结构，通过这个工作展示界面设计中的问题。其间我们还要提出一些设计
    原则。在设计界面时，我们需要做出大量的决定，而其中绝大部分常常又是在无意识中做出的。如果在这个过程中不遵循某些原则，产生出来的可
    能就是某种非常随意的界面，它们将会妨害甚至挫败我们日常的程序设计工作。
    
<br>
####1.逗号分隔的词

        在下面几节里，我们要写出这个库的三个版本，其功能是读CSV数据，将它转换为内部表示。库是需要与其他软件一起工作的软件，在这个工
    作中，我们要讨论一些在设计这类软件时经常遇到的问题。例如，由于没有CSV的标准定义，它的设计不能是基于精确规范进行的，这也是界面设
    计时经常面临的情况。

<br>
####2.一个原型库

        我们不大可能在第一次设计函数库或者界面时就做得很好。事情往往是这样，只有在你已经构造和使用了程序的一个版本之后，才能对如何把
    系统设计正确有足够的认识。
        基于这种理解，我们构造CSV库时准备采用的途径就是：先搞出一个将要丢掉的，搞出一个原型。我们的第一个版本将忽略许多完备的工程
    库应该牵涉的难点，但却又必须足够完整和有用，以便能帮助我们熟悉问题。
        我们的出发点是一个名为csvgetline的函数，它由文件读入一个CSV数据行，将它放入缓冲区，在一个数组里把该行分解为一些数据域，删除
    引号，最后返回数据域的个数：
        ?   char buf[200];      // input line buffer
        ?   char *field[20];    // fields
        
        ?   // csvgetline: read and parse line, return field count
        ?   // sample input: "LU", 86.25, "11/4/1998", "2:19PM", +4.0625
        ?   int csvgetline(FILE *fin)
        ?   {
        ?       int nfield;
        ?       char *p, *q;
        ?    
        ?       if (fgets(buf, sizeof(buf), fin) == NULL)
        ?           return -1;
        ?       nfield = 0;
        ?       for (q = buf; (p = strtok(q, ",\n\r")) != NULL; q = NULL)
        ?            field[nfield++] = unquote(p);
        ?       return nfield;
        ?   }
    函数前面的注释包含了本程序能接受输入行的一个例子，对于理解那些复杂输入的程序而言，这种形式的注释是非常有帮助的。
        由于CSV数据太复杂，不可能简单地用函数scanf做输入剖析，我们使用了C标准库函数strtok。对strtok(p, s)的调用将返回p中的一个标
    识符的指针，标识符完全由不在s中的字符构成。strtok将原串里跟在这个标识符之后的字符用空字符覆盖掉，用这种方式表示标识符的结束。
    在第一次调用时，strtok的第一个参数应该是原来的字符串，随后的调用都应该用NULL作为第一个参数，指明这次扫描应该从前次调用结束的
    地方继续下去。这是一个很糟糕的界面，在函数的不同调用之间，strtok需要在某个隐秘处所存放一个变量。这样，同时激活的调用序列就只
    能有一个，如果有多个无关的调用交替进行，它们之间必定会互相干扰。
        函数unquote的功能是去除像前面例子的数据行里那些表示开头和结束的引号。它并不处理嵌套引号的问题，对于原型而言这样做已足够了。
    当然这种做法还不够一般。
        ?   // unquote: remove leading and trailing quote
        ?   char *unquote(char *p)
        ?   {
        ?       if (p[0] == '"') {
        ?           if (p[strlen(p) - 1] == '"')
        ?               p[strlen(p) - 1] = '\0';
        ?               p++;
        ?       }
        ?       return p;
        ?   }
        下面的简单测试程序可以帮我们确认csvgetline能够工作：
        ?   // csvtest main: test csvgetline function
        ?   int main()
        ?   {
        ?       int i, nf;
        ?       
        ?       while ((nf = csvgetline(stdin)) != -1)
        ?           for (int i = 0; i < nf; i++)
        ?               printf("field[%d] = '%s'\n", i, field[i]);
        ?       return 0;
        ?   }
    在printf里用一对单引号括起数据域，这起着划清界限的作用，还能帮助我们发现空格处理不正确一类的错误。
        我们可以用这个函数处理getquotes.tcl生成的输出：
        % getquotes.tcl | csvtest
        ...
        field[0] = 'LU'
        field[1] = '86.375'
        field[2] = '11/5/1998'
        field[3] = '1:01PM'
        field[4] = '-0.125'
        field[5] = '86'
        field[6] = '86.375'
        field[7] = '85.0625'
        field[8] = '2888600'
        field[0] = 'T'
        field[1] = '61.0625'
        ...
        
        我们在查看了一个数据来源之后设计了这个原型，并且只用同样来源的数据做过一些测试。因此，如果在使用其他来源的数据时发现了程
    序里的大错误，我们一点都不应该对此感到惊奇。长的输入行、很多的数据域以及未预料到的或者欠缺的分隔符都可能造成大麻烦。这个脆弱
    的原型作为个人使用而言可能还勉强，或者可以用来说明这种方法的可行性，但绝不可能有更多的意义。在着手开始下一个实现之前，我们需
    要重新认真地想一想，到底应该如何做这个设计。
        现在这个原型里包含着我们的许多决定，有些是明显的，也有些是隐含的。下面列出的是前面做过的一些选择，对一个通用库而言，它们
    并不都是最好的选择。实际上，每个选择都提出了一个问题，需要进一步仔细考虑。
        ● 原型没有处理特别长的行、很多的域。遇到这种情况时它可能给出错误结果甚至垮台，因为它没有检查溢出，在出现错误时也没有返回
          某种合理的值。
        ● 这里假定输入是由换行字符结尾的行组成。
        ● 数据域由逗号分隔，数据域前后的引号将被去除，但没有考虑嵌套的引号或逗号。
        ● 输入行没有保留，在构造数据域的过程中将它覆盖掉了。
        ● 在从一行输入转到另一行时没有保留任何数据。如果需要记录什么东西，那么就必须做一个拷贝。
        ● 对数据域的访问是通过全局变量（数组field）进行的。这个数组由csvgetline与调用它的函数共享。这里对数据域内容或指针的访问都
          没有任何控制。对于超出最后一个域的访问也没有任何防御措施。
        ● 使用了全局变量，这就使得这个设计不能适合多线程环境，甚至也不允许两个交替进行的调用序列。
        ● 调用库的程序必须显示的打开和关闭文件，csvgetline做的只是从已经打开的文件读入数据。
        ● 输入和划分从操作纠缠在一起：每个调用读入一行并把它切分为一些域，不管实际应用中是否真的需要后一个服务。
        ● 函数返回值表示一个输入行中的数据域的个数，每行都被切分，以便得到这个数值。这里也没有办法把出现错误和文件结束区分开。
        ● 除了更改代码外，没有任何办法来改变这些特性。
        
    
    
    
    
    
    
    
    
    
    
    
