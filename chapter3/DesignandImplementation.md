###设计与实现

    数据结构的设计是程序构造过程的中心环节。一旦数据结构安排好了，算法就像是瓜熟蒂落，编码也比较容易。
    程序设计语言的选择在整个设计过程中，相对而言，并不是那么重要。
    
    我们准备做的就是产生一些随机的可以读的英语文本。
    
<br>
####1.马尔可夫链算法

        完成这种处理有一种非常漂亮的方法，那就是使用一种称为马尔可夫链算法的技术。们可以把输入想像成由一些互相重叠的短语
    构成的序列，而该算法把每个短语分割为两个部分：一部分是由多个词构成的前缀，另一部分是只包含一个词的后缀。马尔可夫链算
    法能够生成输出短语的序列，其方法是依据 (在我们的情况下)原文本的统计性质，随机性地选择跟在前缀后面的特定后缀。采用三个
    词的短语就能够工作得很好——利用连续两个词构成的前缀来选择作为后缀的一个词：
        设置w1和w2为文本的前两个词
        输出w1和w2
        循环：
            随机的选出w3，它是文本中w1w2的后缀中的一个
            打印w3
            把w2和w3分别换成w2和w3
            重复循环
    为了说明问题，假设我们要基于本章开头的引语里的几个句子生成一些随机文本。这里采用的是两词前缀：
        Show your flowcharts and conceal your tables and I will be
        mystified. Show your tables and your flowcharts will be
        obvious. (end)
        下面是一些输入词对和跟随它们之后的词：
            输入前缀                        跟随的后缀词
            Show your                   flowcharts tables
            your flowercharts           and will
            flowcharts and              conceal
            flowcharts will             be
            your tables                 and and
            will be                     mystifid. obvious.
            be mystifid.                Show
            be obvious.                 (end)
        处理这个文本的马尔可夫算法将首先打印出Show your，然后随机取出flowcharts或tables。如果选中了前者，那么现在前缀
    就变成了your flowcharts，而下一个词应该是and或will。如果它选取tables，下一个词就应该是and。这样继续下去，知道产生
    出足够多的输出，后者在找后缀是遇到了结束标志。
        我们的程序将读入一段英语文本，并利用马尔可夫链算法，基于文本中固定长度的短语的出现频率，产生一段新文本。前缀
    中词的数目是个参数，上面用的是 2。如果将前缀缩短，产生出来的东西将趋向于无聊词语，更加缺乏内聚力；如果加长前缀，
    则趋向于产生原始输入的逐字拷贝。对于英语文本而言，用两个词的前缀选择第三个是一个很好的折衷方式。看起来它既能重现
    输入的风味，又能加上程序的古怪润饰。

<br>
####2.数据结构的选择

        我们需要有一种数据结构，它能较好地表示前缀以及与之相关联的后缀。程序将分两部分，第一部分是输入，它构造表示短
    语的整个数据结构；第二部分是随后的输出，它使用这个数据结构，生成随机的输出。这两部分都需要(快速地)查询前缀：输入
    过程中需要更新与前缀相关的后缀；输出时需要对可能后缀做随机选择。这些分析提醒我们使用一种散列结构，其关键码是前缀，
    其值是对应于该前缀的所有可能后缀的集合。
        为了描述的方便，我们将假定采用二词前缀，在这种情况下，每个输出词都是根据它前面的一对词得到的。前缀中词的个数
    对设计本身并没有影响，程序应该能对付任意的前缀长度，但给定一个数能使下面的讨论更具体些。我们把一个前缀和它所有可
    能后缀的集合放在一起，称其为一个状态，这是马尔可夫算法的标准术语。
        对于一个特定前缀，我们需要存储所有能跟随它的后缀，以便将来取用。这些后缀是无序的，一次一个地加进去。我们不知
    道后缀将会有多少，因此，需要一种能容易且高效地增长的数据结构，例如链表或者动态数组。在产生输出的时候，我们要能从
    关联于特定前缀的后缀集合中随机地选出一个后缀。还有，数据项绝不会被删除。
        如果一个短语出现多次，那么又该怎么办？例如，短语“ might appear twice”可能在文本里出现两次，而“might appear
    once”只出现了一次。这个情况有两种可能的表示方式：或者在“might appear”的后缀表里放两个“twice”；或者是只放一个，
    但还要给它附带一个计数值为2的计数器。我们对用或不用计数器的方式都做过试验。不用计数器的情况处理起来比较简单，因
    为在加入后缀时不必检查它是否已经存在。试验说明这两种方式在执行时间上的差别是微不足道的。
    
        总结一下：每个状态由一个前缀和一个后缀链表组成。所有这些信息存在一个散列表里，以前缀作为关键码。每个前缀是一
    个固定大小的词集合。如果一个后缀在给定前缀下的出现多余一次，则每个出现都单独包含在有关链表里。
    
<br>
####3.在C中构造数据结构

        现在开始考虑C语言中的实现。首先定义一些常数：
        enum {
            NPREF   = 2,        // number of prefix words
            NHASH   = 4093,     // size of state hash table array
            MAXGEN  = 10000     // maximum words generated
        };
    这个声明定义了前缀中词的个数（NPREF），散列表数组的大小（NHASH），生成词数的上界（MAXGEN）。如果NPREF是个编译时的
    常数而不是运行时的变量，程序里的存储管理将会更简单些。数组的规模设的相当大，因为我们预计程序可能处理很大的输入文
    件，或许是整本书。选择NHASH=4093，这样，即使输入里有10000个不同前缀（词对），平均链长仍然会很短，大约两个到三个前
    缀。数组越大，链的期望长度越短，查询进行得也越快。实际上，这个程序还仍然是个摆设，因此其性能并不那么关键。另一方
    面，如果选用的数组太小，程序将无法在合理时间里处理完可能的输入。而如果它太大，又可能无法放进计算机的存储器中。
        前缀可以用词的数组方式存储。散列表的元素用State（状态）数据类型表示，它是前缀与Suffix（后缀）链表的关联：
        typedef struct State State;
        typedef struct Suffix Suffix;
        struct State { /* prefix + suffix list */
            char    *pref[NPREF];   // prefix words
            Suffix  *suf;           // list of suffixes
            State   *next;          // next in hash table
        };
        
        struct Suffix { /* list of suffixes */
            char    *word;          // suffix
            Suffix  *next;          // next in list of suffixes
        };
        
        State *statetab[NHASH];
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
