###风格

<br>
####1.全局变量使用具有描述意义的名字，局部变量用短名字。

        全局变量可以出现在整个程序中的任何地方，因此它们的名字应该足够长，具有足够的说明性，以便使读者能够记得它们是干什
    么用的。给每个全局变量声明附一个简短注释也非常有帮助：
        int npending = 0; // current length of input queue
    全局函数、类和结构也都应该有说明性的名字，以表明它们在程序里扮演的角色。
        相反，对局部变量使用短名字就够了。

<br>
####2.保持一致性。

        除了太长之外，下面这个Java类中各成员的名字一致性也很差：
        ?    class UserQueue {
        ?        int noOfItemInQ, frontOfTheQueue, queueCapacity;
        ?        public int noOfUsersInQueue() {...}
        ?    }
    这里同一个词“队列（queue）”在名字里被分别写为Q、Queue或queue。由于只能在类型UserQueue里访问，类成员的名字中完全不必提
    到队列，因为存在上下文。所以：
        ?   queue.queueCapacity
    完全是多余的。下面的写法更好：
        class UserQueue {
            int nitems, front, capacity;
            public int nusers() {...}
        }
    因为这时可以如此写：
        queue.capacity++;
        n = queue.nusers();
    这样做在清晰性方面没有任何损失。在这里还有可做的事情。例如items和users实际是同一种东西，同样的东西应该使用一个概念。
    
<br>
####3.函数采用动作性的名字。

        函数名应当用动作性的动词，后面可以跟着名词：
            now = date.getTime();
            putchar('\n');
    对返回布尔类型值（真或者假）的函数命名，应该清楚的反映其返回值情况。下面这样的语句
        ?   if (checkoctal(c)) ...
    是不好的，因为它没有指明什么时候返回真，什么时候返回假。而：
        if (isoctal(c)) ...
    就把事情说清楚了：如果参数是八进制数字则返回真，否则返回假。

<br>
####4.要准确。

        名字不仅是个人标记，它还携带着给读程序人的信息。误用的名字可能引起奇怪的程序错误。
        本书作者之一写过一个名为isoctal的宏，并且发布使用多年，而实际上它的实现是错误的：
        ?   #define isoctal(c) ((c) >= '0' && (c) <= '8')
    正确的应该是：
        #define isoctal(c) ((c) >= '0' && (c) <= '7')
        
        另外一种情况：名字具有正确的含义，而对应的实现确实错的，一个合情合理的名字掩盖了一个害人的实现。
        下面的这个例子，其中名字和实现完全是矛盾的：
        ?   public boolean inTable(Object obj) {
        ?       int j = this.getIndex(obj);
        ?       return (j == nTable);
        ?   }
    函数getIndex如果找到了相关对象，就返回0到nTable-1之间的一个值，否则返回nTable的值。而这里inTable返回的布尔值却正好
    与它名字所说的相反。在写这段代码时，这种写法未必会引起什么问题。但如果后来修改这个程序，很可能是由别的程序员来做，
    这个名字肯定会把人弄糊涂。
    
<br>
####5.以缩行显示程序的结构。

        采用一种一致的缩行风格，是使程序呈现出结构清晰的最省力的方法。

<br>
####6.使用表达式的自然形式。

        表达式应该写的你能大声念出来。含有否定运算的条件表达式比较难理解：
        ?   if (!(block_id < actblks) || !(block_id >= unblocks))
        ?   ...
    在两个测试中都用到否定，而它们都不是必要的。应该改变关系运算符的方向，是测试变成肯定的：
        if ((block_id >= actblks) || (block_id < unblocks))
        ...
    现在代码读起来就自然多了。
    
<br>
####7.用加括号的方式排除二义性。

        括号表示分组，即使有时并不必要，加了括号也可能把意图表示的更清楚。
        
<br>
####8.分解复杂的表达式。

        C、C++和Java语言都有很丰富的表达式语法结构和很丰富的运算符。因此在这些语言里就很容易把一大堆东西塞进一个结构中。
        
<br>
####9.要清晰。

        程序员有时把自己无穷的创造力用到了写最简短的代码上，或者用在寻求得到结果的最巧妙方法上。有时这种技能用错了地方，
    因为我们的目标应该是写出最清晰的代码，而不是最巧妙的代码。
        下面这个难懂的计算到底想做什么？
        ?   subkey = subkey >> (bitoff - ((bitoff >> 3) << 3));
    最内层表达式把bitoff右移3位，结果又被重新移回来。这样做实际上是把变量的最低3位设置为0。从bitoff的原值里减掉这个结
    果，得到的是bitoff的最低3位。最后用这3位的值确定subkey的右移位数。
        上面的表达式与下面这个等价：
        subkey = sunkey >> (bitoff & 0x7);
    要弄清楚前一个版本的意思简直像猜谜语，而后面这个则又短又清楚。经验丰富的程序员会把它写得更短，换一个赋值运算符：
        subkey >>= bitoff & 0x7;
        
        有些结构似乎总要引诱人去滥用它们。运算符?:大概属于这一类。
        运算符?:适用于短的表达式，这是它可以把4行的if-else程序变成1行，例如这样：
        max = (a > b) ? a : b;
    或者是下面这样：
        printf("The list has %d item%s\n", n, n==1 ? "" : "s");
    但是它不应该作为条件语句的一般性替换。
        
<br>
####10.当心副作用。

        像++这一类的运算符具有副作用，它们除了返回一个值外，还将隐含的改变变量的值。副作用有时用起来很方便，但有时也
    会成为问题，因为变量的取值操作和更新操作可能不是同事发生。C和C++对于副作用有关的执行顺序并没有明确定义，因此，下
    面的多次赋值语句很可能将产生错误结果：
        ?   str[i++] = str[i++] = ' ';
    这样写的意图是给str中的随后两个位置赋空格值，但实际效果却要依赖i的更新时刻，很可能把str里的一个位置跳过去，也可能
    导致只对i实际更新一次。这里应该把它分成两个语句：
        str[i++] = ' ';
        str[i++] = ' ';
        下面的赋值语句虽然只包含一个增量操作，但也可能给出不同的结果：
        ?   array[i++] = i;
        如果初始时i的值是3，那么数组元素有可能被设置成3或者4。
        
        不仅增量和减量操作有副作用，I/O也是一种附带地下活动的操作。下面的例子希望从标准输入读入两个互相有关的数：
        ?   scanf("%d %d", &yr, &profit[yr]);
    这样做很有问题，因为在这个表达式里的一个地方修改了yr，而在另一个地方又使用它。这样，除非yr的新取值和原来的值相同，
    否则profit[yr]就不可能是正确的。你可能认为事情依赖于求值得顺序，实际情况并不是这样。这里的问题是：scanf的所有参数
    都在函数被真正调用前已经求好值了，所以&profit[yr]实际使用的总是yr原来的值。这种问题可能发生在任何语言里。纠正的方
    法就是把语句分解为两个：
        scanf("%d", &yr);
        scanf("%d", &profit[yr]);
