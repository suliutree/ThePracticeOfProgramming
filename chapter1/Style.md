###风格

<br>
####1.全局变量使用具有描述意义的名字，局部变量用短名字。

        全局变量可以出现在整个程序中的任何地方，因此它们的名字应该足够长，具有足够的说明性，以便使读者能够记得它们是干什
    么用的。给每个全局变量声明附一个简短注释也非常有帮助：
        int npending = 0; // current length of input queue
    全局函数、类和结构也都应该有说明性的名字，以表明它们在程序里扮演的角色。
        相反，对局部变量使用短名字就够了。

<br>
####2.保持一致性。

        除了太长之外，下面这个Java类中各成员的名字一致性也很差：
        ?    class UserQueue {
        ?        int noOfItemInQ, frontOfTheQueue, queueCapacity;
        ?        public int noOfUsersInQueue() {...}
        ?    }
    这里同一个词“队列（queue）”在名字里被分别写为Q、Queue或queue。由于只能在类型UserQueue里访问，类成员的名字中完全不必提
    到队列，因为存在上下文。所以：
        ?   queue.queueCapacity
    完全是多余的。下面的写法更好：
        class UserQueue {
            int nitems, front, capacity;
            public int nusers() {...}
        }
    因为这时可以如此写：
        queue.capacity++;
        n = queue.nusers();
    这样做在清晰性方面没有任何损失。在这里还有可做的事情。例如items和users实际是同一种东西，同样的东西应该使用一个概念。
    
<br>
####3.函数采用动作性的名字。

        函数名应当用动作性的动词，后面可以跟着名词：
            now = date.getTime();
            putchar('\n');
    对返回布尔类型值（真或者假）的函数命名，应该清楚的反映其返回值情况。下面这样的语句
        ?   if (checkoctal(c)) ...
    是不好的，因为它没有指明什么时候返回真，什么时候返回假。而：
        if (isoctal(c)) ...
    就把事情说清楚了：如果参数是八进制数字则返回真，否则返回假。

<br>
####4.要准确。

        名字不仅是个人标记，它还携带着给读程序人的信息。误用的名字可能引起奇怪的程序错误。
        本书作者之一写过一个名为isoctal的宏，并且发布使用多年，而实际上它的实现是错误的：
        ?   #define isoctal(c) ((c) >= '0' && (c) <= '8')
    正确的应该是：
        #define isoctal(c) ((c) >= '0' && (c) <= '7')
        
        另外一种情况：名字具有正确的含义，而对应的实现确实错的，一个合情合理的名字掩盖了一个害人的实现。
        下面的这个例子，其中名字和实现完全是矛盾的：
        ?   public boolean inTable(Object obj) {
        ?       int j = this.getIndex(obj);
        ?       return (j == nTable);
        ?   }
    函数getIndex如果找到了相关对象，就返回0到nTable-1之间的一个值，否则返回nTable的值。而这里inTable返回的布尔值却正好
    与它名字所说的相反。在写这段代码时，这种写法未必会引起什么问题。但如果后来修改这个程序，很可能是由别的程序员来做，
    这个名字肯定会把人弄糊涂。
    
<br>
####5.以缩行显示程序的结构。

        采用一种一致的缩行风格，是使程序呈现出结构清晰的最省力的方法。

<br>
####6.使用表达式的自然形式。

        表达式应该写的你能大声念出来。含有否定运算的条件表达式比较难理解：
        ?   if (!(block_id < actblks) || !(block_id >= unblocks))
        ?   ...
    在两个测试中都用到否定，而它们都不是必要的。应该改变关系运算符的方向，是测试变成肯定的：
        if ((block_id >= actblks) || (block_id < unblocks))
        ...
    现在代码读起来就自然多了。
    
<br>
####7.用加括号的方式排除二义性。

        括号表示分组，即使有时并不必要，加了括号也可能把意图表示的更清楚。
        
<br>
####8.分解复杂的表达式。

        C、C++和Java语言都有很丰富的表达式语法结构和很丰富的运算符。因此在这些语言里就很容易把一大堆东西塞进一个结构中。
        
<br>
####9.要清晰。

        程序员有时把自己无穷的创造力用到了写最简短的代码上，或者用在寻求得到结果的最巧妙方法上。有时这种技能用错了地方，
    因为我们的目标应该是写出最清晰的代码，而不是最巧妙的代码。
        下面这个难懂的计算到底想做什么？
        ?   subkey = subkey >> (bitoff - ((bitoff >> 3) << 3));
    最内层表达式把bitoff右移3位，结果又被重新移回来。这样做实际上是把变量的最低3位设置为0。从bitoff的原值里减掉这个结
    果，得到的是bitoff的最低3位。最后用这3位的值确定subkey的右移位数。
        上面的表达式与下面这个等价：
        subkey = sunkey >> (bitoff & 0x7);
    要弄清楚前一个版本的意思简直像猜谜语，而后面这个则又短又清楚。经验丰富的程序员会把它写得更短，换一个赋值运算符：
        subkey >>= bitoff & 0x7;
        
        有些结构似乎总要引诱人去滥用它们。运算符?:大概属于这一类。
        运算符?:适用于短的表达式，这是它可以把4行的if-else程序变成1行，例如这样：
        max = (a > b) ? a : b;
    或者是下面这样：
        printf("The list has %d item%s\n", n, n==1 ? "" : "s");
    但是它不应该作为条件语句的一般性替换。
        
<br>
####10.当心副作用。

        像++这一类的运算符具有副作用，它们除了返回一个值外，还将隐含的改变变量的值。副作用有时用起来很方便，但有时也
    会成为问题，因为变量的取值操作和更新操作可能不是同事发生。C和C++对于副作用有关的执行顺序并没有明确定义，因此，下
    面的多次赋值语句很可能将产生错误结果：
        ?   str[i++] = str[i++] = ' ';
    这样写的意图是给str中的随后两个位置赋空格值，但实际效果却要依赖i的更新时刻，很可能把str里的一个位置跳过去，也可能
    导致只对i实际更新一次。这里应该把它分成两个语句：
        str[i++] = ' ';
        str[i++] = ' ';
        下面的赋值语句虽然只包含一个增量操作，但也可能给出不同的结果：
        ?   array[i++] = i;
        如果初始时i的值是3，那么数组元素有可能被设置成3或者4。
        
        不仅增量和减量操作有副作用，I/O也是一种附带地下活动的操作。下面的例子希望从标准输入读入两个互相有关的数：
        ?   scanf("%d %d", &yr, &profit[yr]);
    这样做很有问题，因为在这个表达式里的一个地方修改了yr，而在另一个地方又使用它。这样，除非yr的新取值和原来的值相同，
    否则profit[yr]就不可能是正确的。你可能认为事情依赖于求值得顺序，实际情况并不是这样。这里的问题是：scanf的所有参数
    都在函数被真正调用前已经求好值了，所以&profit[yr]实际使用的总是yr原来的值。这种问题可能发生在任何语言里。纠正的方
    法就是把语句分解为两个：
        scanf("%d", &yr);
        scanf("%d", &profit[yr]);

<br>
####11.使用一致的缩行和加括号风格。

        应该在那些不必须用花括号的地方都加上他们吗？与一般的圆括号一样，或括号也可以用来消除歧义，但是在使代码更清晰
    方面的作用却不那么大。为了保持一致性，许多程序员总在循环或if体外加花括号。当这里只有一个语句时，加花括号就不是必
    要的，所以作者倾向于去掉它们。

<br>
####12.为了一致性，使用习惯用法。

        常见的习惯用法之一是循环形式。考虑在C、C++和Java中逐个处理n元数组中各个元素的代码，例如要对这些元素做初始化。
    有人可能写出下面的循环：
        ?   i = 0;
        ?   while (i <= n-1)
        ?       array[i++] = 1.0;
    或者是这样的：
        ?   for (i = 0; i < n; )
        ?       array[i++] = 1.0;
    也可能是：
        ?   for (i = n; --i >= 0; )
        ?       array[i] = 1.0;
    所有这些都正确，而习惯的用法确是：
        for (i = 0; i < n; i++)
            array[i] = 1.0;
    这并不是一种随意的选择，熟悉C语言的人不用琢磨就能理解它，不加思考就能正确的写出来。
    
        对于无穷循环，我们喜欢用：
        for (;;)
            ...
    但
        while (1)
            ...
    也很流行，不要使用其他形式。
    
        一致地使用习惯还有另一个优点，那就是使非标准的循环很容易被注意到，这种情况常常预示着有什么问题：
        ?   int i, *iArray, nmemb;
        ?
        ?   iArray = malloc(nmemb * sizeof(int));
        ?   for (i = 0; i <= nmemb; i++)
        ?       iArray[i] = i;
    在这里分配了nmemb个项的空间，从iArray[0]到iArray[nmemb-1]。但由于采用的是<=做循环测试，程序执行将超出数组尾部，覆
    盖掉存储区中位于数组后面的内容。不幸的是，有许多像这样的错误没能及时查出来，直接造成了很大的损害。
    
        C和C++中也有为字符串分配空间及操作它们的习惯写法。不采用这种做法的代码常常隐藏着程序错误：
        ?   char *p, buf[256];
        ?
        ?   gets(buf);
        ?   p = malloc(strlen(buf));
        ?   strcpy(p, buf);
    绝不要使用函数gets，因为你没办法限制它由输入那儿读入内容的数量。这常常会导致一个安全性问题。第6章会再来讨论这个问
    题，哪里要说明选择fgets总是更好的。上面代码段还有另一个问题：strlen求出的值没有计入串结尾的'\0'字符，而strcpy却将
    复制它。所以这里分配的空间实际上是不够的，这将使strcpy的写入超过所分配空间的界限。习惯写法是：
        p = malloc(strlen(buf) + 1);
        strcpy(p, buf);
    或在C++里：
        p = new char[strlen(buf) + 1];
        strcpy(p, buf);
    如果你在这里没看见+1，就要当心。
        在Java里不会遇到这个特殊问题，那里的字符串不是用零结尾的数组表示，数组的下标也将受到检查。这就使Java不会出现
    超出数组界限访问的问题。
        在实际程序中，对于malloc、realloc、strdup及任何牵涉到存储分配的函数，它们的返回值都必须做检查。
        
<br>
####13.用else-if表达多路选择。

        一系列嵌套的if语句通常是说明了一段粗劣笨拙的代码，或许就是真正的错误。

<br>
####14.避免使用函数宏。

        在C++里，在线函数更消减了函数宏的用武之地，在Java里根本就没有宏这种东西。即使是在C语言里，它们带来的麻烦也比
    解决的问题多。
        函数宏最常见的一个严重问题是：如果一个参数在定义中出现多次，它可能被多次求职。如果调用时的实际参数带有副作用，
    结果就会产生一个难以捉摸的错误。下面的代码段来自某个<ctype.h>，其意图是实现一种字符测试：
        ?   #define isupper(c)  ((c) >= 'A' && (c) <= 'Z')
    请注意，参数C在宏的体里出现了两次。如果isupper在下面的上下文中调用：
        ?   while (isupper(c = getchar()))
        ?   ...
    那么，每当遇到一个大于等于A的字符，程序就会将它丢掉，而下一个字符将被读入并去与Z做比较。C语言标准是仔细写出的，它
    允许将isupper及类似的函数定义为宏，但要保证它们的参数只求值一次。因此上面的实现是错误的。
    
        宏将在它每次被调用的地方进行实例化，结果会导致被编译的程序变大（C++的在线函数也存在这个缺点）。

<br>
####15.给宏的体和参数都加上括号。

        即使是在宏的定义里完全加上括号，也不可能解决前面所说的多次求值的问题。所以，如果一个操作比较复杂，或者它很具
    有一般性，值得包装起来，那么还是应该使用函数。
    
        C++提供的在线函数既避免了语法方面的麻烦，而且又可得到宏能够提供的执行效率，很适合用来定义那些设置或者提取一个
    值的短小函数。


        
        
        
        
